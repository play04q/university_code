##系统分析
蜂鸣器是一种将电信号转换为声音信号的器件，常用来产生设备的按键音、报警音等提示信号。按驱动方式可分为有源蜂鸣器和无源蜂鸣器，有源蜂鸣器是内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定，而无源蜂鸣器则是内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音。
使用51单片机控制无源蜂鸣器的振荡脉冲的频率，使之发出不同的音符，再控制发出每一个音符的时间，就可以控制蜂鸣器演奏音乐。
##设计原理
运用51单片机的一个引脚来控制无源蜂鸣器的震荡脉冲的频率，根据音乐知识，设置不同的音符相应的频率，达到发出音符的声音，之后在控制每个音符发出声音的时间，来控制节奏，这样是蜂鸣器演奏音乐。
##系统设计功能框图

##系统设计原理图

##程序流程图

##编程
```c
#include <REGX52.H>
sbit speaker = P2^5;
unsigned char timer0h, timer0l, time;
//--------------------------------------
//单片机晶振采用11.0592MHz
// 频率-半周期数据表 高八位 本软件共保存了四个八度的28个频率数据
code unsigned char FREQH[] = {
0xF2, 0xF3, 0xF5, 0xF5, 0xF6, 0xF7, 0xF8, //低音1234567
0xF9, 0xF9, 0xFA, 0xFA, 0xFB, 0xFB, 0xFC, 0xFC,//1,2,3,4,5,6,7,i
0xFC, 0xFD, 0xFD, 0xFD, 0xFD, 0xFE, //高音 234567
0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFF}; //超高音 1234567
// 频率-半周期数据表 低八位
code unsigned char FREQL[] = {
0x42, 0xC1, 0x17, 0xB6, 0xD0, 0xD1, 0xB6, //低音1234567
0x21, 0xE1, 0x8C, 0xD8, 0x68, 0xE9, 0x5B, 0x8F, //1,2,3,4,5,6,7,i
0xEE, 0x44, 0x6B, 0xB4, 0xF4, 0x2D, //高音 234567
0x47, 0x77, 0xA2, 0xB6, 0xDA, 0xFA, 0x16}; //超高音 1234567
//--------------------------------------
code unsigned char sszymmh[] = 
{
4,2,4, 2,2,2, 4,2,2, 3,2,4, 1,2,2, 6,1,2, 
4,2,1, 3,2,1, 2,2,1, 1,2,1, 2,2,2, 6,2,2, 3,2,4, 6,1,4,
2,2,2, 1,2,1, 7,1,1, 6,1,1, 5,1,1, 6,1,1, 7,1,1, 6,1,2, 3,2,4, 6,1,2,
2,2,1, 2,2,1, 1,2,1, 7,1,1, 6,1,1, 5,1,1, 6,1,1, 7,1,1, 6,1,2, 3,2,4, 	
};//歌曲
//世上只有妈妈好数据表 要想演奏不同的乐曲, 只需要修改这个数据表
//code unsigned char sszymmh[] = {
//6, 2, 3, 5, 2, 1, 3, 2, 2, 5, 2, 2, 1, 3, 2, 6, 2, 1, 5, 2, 1,
//一个音符有三个数字。前为第几个音、中为第几个八度、后为时长（以半拍为单位）。
//6, 2, 3代表：6, 中音, 3个半拍;
//5, 2, 1代表：5, 中音, 1个半拍;
//3, 2, 2代表：3, 中音, 2个半拍;
//5, 2, 2代表：5, 中音, 2个半拍;
//1, 3, 2代表：1, 高音, 2个半拍;
//
//6, 2, 4, 3, 2, 2, 5, 2, 1, 6, 2, 1, 5, 2, 2, 3, 2, 2, 1, 2, 1,
//6, 1, 1, 5, 2, 1, 3, 2, 1, 2, 2, 4, 2, 2, 3, 3, 2, 1, 5, 2, 2,
//5, 2, 1, 6, 2, 1, 3, 2, 2, 2, 2, 2, 1, 2, 4, 5, 2, 3, 3, 2, 1,
//2, 2, 1, 1, 2, 1, 6, 1, 1, 1, 2, 1, 5, 1, 6, 0, 0, 0,,,,,,,,,,,,,,,,,,,,,6,2,3, 6,2,1, 1,3,2, 7,2,1, 6,2,1, 5,2,2, 3,2,1, 5,2,1, 6,2,4, 3,2,3,};
//--------------------------------------
void t0int() interrupt 1 //T0中断程序，控制发音的音调
{
TR0 = 0; //先关闭T0
speaker = !speaker; //输出方波, 发音
TH0 = timer0h; //下次的中断时间, 这个时间, 控制音调高低
TL0 = timer0l;
TR0 = 1; //启动T0
}
//--------------------------------------
void delay(unsigned char t) //延时程序，控制发音的时间长度
{
unsigned char t1;
unsigned long t2;
for(t1 = 0; t1 < t; t1++) //双重循环, 共延时t个半拍
for(t2 = 0; t2 < 8000; t2++); //延时期间, 可进入T0中断去发音
TR0 = 0; //关闭T0, 停止发音
}
//--------------------------------------
void song() //演奏一个音符
{
TH0 = timer0h; //控制音调
TL0 = timer0l;
TR0 = 1; //启动T0, 由T0输出方波去发音
delay(time); //控制时间长度
}
//--------------------------------------
void main(void)
{
	while(1)
	{
		unsigned char k, i;
		TMOD = 1; //置T0定时工作方式1
		ET0 = 1; //开T0中断
		EA = 1; //开CPU中断
		while(1) {
		i = 0;
		time = 1;
		while(time) {
		k = sszymmh[i] + 7 * sszymmh[i + 1] - 1;
		//第i个是音符, 第i+1个是第几个八度
		timer0h = FREQH[k]; //从数据表中读出频率数值
		timer0l = FREQL[k]; //实际上, 是定时的时间长度
		time = sszymmh[i + 2]; //读出时间长度数值
		i += 3;
		song(); //发出一个音符
		}
		}
	}
}

```
##系统调试运行或仿真情况
仿真良好，比较好的播放出了音乐。